diff -u -r -N android_kernel_htc_primoc/arch/arm/configs/primoc_defconfig android_kernel_htc_primoc.new/arch/arm/configs/primoc_defconfig --- 
android_kernel_htc_primoc/arch/arm/configs/primoc_defconfig	2012-10-30 01:04:21.268133098 +0100 +++ 
android_kernel_htc_primoc.new/arch/arm/configs/primoc_defconfig	2012-10-30 01:12:18.351345373 +0100 @@ -861,22 +861,13 @@
 # CONFIG_HAMRADIO is not set CONFIG_CAN is not set CONFIG_IRDA is not set
-CONFIG_BT=y -# CONFIG_BT_SCO is not set -CONFIG_BT_RFCOMM=y -# CONFIG_BT_RFCOMM_TTY is not set -CONFIG_BT_BNEP=m -# CONFIG_BT_BNEP_MC_FILTER is not set -# 
CONFIG_BT_BNEP_PROTO_FILTER is not set -CONFIG_BT_HIDP=m -CONFIG_BT_HID_BRCM=y
 
 #
 # Bluetooth device drivers
 #
 # CONFIG_BT_HCIBTSDIO is not set
-# CONFIG_BT_HCIUART is not set -# CONFIG_BT_HCIUART_H4 is not set +CONFIG_BT_HCIUART=y +CONFIG_BT_HCIUART_H4=y
 # CONFIG_BT_HCIUART_IBS is not set CONFIG_MSM_BT_POWER is not set CONFIG_BT_HCIVHCI is not set
@@ -893,6 +884,16 @@
 CONFIG_LIB80211=y
 CONFIG_BTPORT=y
 CONFIG_BTPORT_DRV=y +CONFIG_BT=y +CONFIG_BT_L2CAP=y +CONFIG_BT_SCO=y +CONFIG_BT_RFCOMM=y +# CONFIG_BT_RFCOMM_TTY is not set +CONFIG_BT_BNEP=y +# 
CONFIG_BT_BNEP_MC_FILTER is not set +# CONFIG_BT_BNEP_PROTO_FILTER is not set +CONFIG_BT_HIDP=y +CONFIG_BT_HID_BRCM=y
 
 #
 # CFG80211 needs to be enabled for MAC80211
@@ -1165,9 +1166,10 @@
 CONFIG_SERIAL_MSM_CONSOLE=y
 CONFIG_SERIAL_MSM_CLOCK_CONTROL=y
 # CONFIG_SERIAL_MSM_RX_WAKEUP is not set
-CONFIG_SERIAL_MSM_HS=y +# CONFIG_SERIAL_MSM_HS is not set
 # CONFIG_SERIAL_MSM_HS_PURE_ANDROID is not set
-# CONFIG_SERIAL_BCM_BT_LPM is not set +CONFIG_SERIAL_BCM_BT_LPM=y +CONFIG_SERIAL_MSM_HS_LPM=y
 # CONFIG_SERIAL_TIMBERDALE is not set CONFIG_SERIAL_ALTERA_JTAGUART is not set CONFIG_SERIAL_ALTERA_UART is not set
diff -u -r -N android_kernel_htc_primoc/arch/arm/mach-msm/board-primoc.c android_kernel_htc_primoc.new/arch/arm/mach-msm/board-primoc.c --- 
android_kernel_htc_primoc/arch/arm/mach-msm/board-primoc.c	2012-10-30 01:04:21.335133128 +0100 +++ 
android_kernel_htc_primoc.new/arch/arm/mach-msm/board-primoc.c	2012-10-30 00:58:16.798963069 +0100 @@ -114,6 +114,10 @@
 #include <mach/htc_bdaddress.h> endif
 
+#ifdef CONFIG_SERIAL_BCM_BT_LPM +#include <mach/bcm_bt_lpm.h> +#endif +
 #ifdef CONFIG_MFD_MAX8957 include <linux/mfd/pmicmax8957.h> include <linux/max8957_gpio.h>
@@ -3423,18 +3427,40 @@
 };
 #endif
 
-#ifdef CONFIG_SERIAL_MSM_HS +#if defined(CONFIG_SERIAL_MSM_HS) || defined(CONFIG_SERIAL_MSM_HS_LPM)
 static struct msm_serial_hs_platform_data msm_uart_dm1_pdata = { + .rx_wakeup_irq = -1,
 	.inject_rx_on_wakeup = 0, -	.cpu_lock_supported = 1,
 
+#ifdef CONFIG_SERIAL_BCM_BT_LPM +	.exit_lpm_cb = bcm_bt_lpm_exit_lpm_locked, +#else
 	/* for bcm BT */
 	.bt_wakeup_pin_supported = 1,
 	.bt_wakeup_pin = PRIMOC_GPIO_BT_WAKE,
 	.host_wakeup_pin = PRIMOC_GPIO_BT_HOST_WAKE, +#endif +}; + +#ifdef CONFIG_SERIAL_BCM_BT_LPM +static struct bcm_bt_lpm_platform_data bcm_bt_lpm_pdata = { 
+ .gpio_wake = PRIMOC_GPIO_BT_WAKE, + .gpio_host_wake = PRIMOC_GPIO_BT_HOST_WAKE, + .request_clock_off_locked = msm_hs_request_clock_off_locked, + 
.request_clock_on_locked = msm_hs_request_clock_on_locked, +}; + +struct platform_device bcm_bt_lpm_device = { + .name = "bcm_bt_lpm", + .id = 0, + .dev = { + 
.platform_data = &bcm_bt_lpm_pdata, +	},
 };
 #endif
 
+#endif +
 #ifdef CONFIG_BT
 static struct platform_device primoc_rfkill = {
 	.name = "primoc_rfkill", @@ -3835,8 +3861,11 @@
 #endif
 	&msm_ebi0_thermal,
 	&msm_ebi1_thermal, -#ifdef CONFIG_SERIAL_MSM_HS - &msm_device_uart_dm1, +#ifdef CONFIG_SERIAL_BCM_BT_LPM + &bcm_bt_lpm_device, +#endif +#if 
defined(CONFIG_SERIAL_MSM_HS) || defined(CONFIG_SERIAL_MSM_HS_LPM) + &msm_device_uart_dm1,
 #endif ifdef CONFIG_BT
 	&primoc_rfkill, @@ -5210,9 +5239,16 @@
 	bt_export_bd_address();
 #endif
 
+#if defined(CONFIG_SERIAL_MSM_HS) || defined(CONFIG_SERIAL_MSM_HS_LPM) +#ifndef CONFIG_SERIAL_BCM_BT_LPM +	msm_uart_dm1_pdata.rx_wakeup_irq = 
gpio_to_irq(PRIMOU_GPIO_BT_HOST_WAKE); +#endif
 #ifdef CONFIG_SERIAL_MSM_HS
-	msm_uart_dm1_pdata.rx_wakeup_irq = gpio_to_irq(PRIMOC_GPIO_BT_HOST_WAKE);
 	msm_device_uart_dm1.name = "msm_serial_hs_brcm"; +#endif +#ifdef CONFIG_SERIAL_MSM_HS_LPM +	msm_device_uart_dm1.name = "msm_serial_hs_brcm_lpm"; 
+#endif
 	msm_device_uart_dm1.dev.platform_data = &msm_uart_dm1_pdata;
 #endif
 
diff -u -r -N android_kernel_htc_primoc/arch/arm/mach-msm/clock-7x30.c android_kernel_htc_primoc.new/arch/arm/mach-msm/clock-7x30.c --- 
android_kernel_htc_primoc/arch/arm/mach-msm/clock-7x30.c	2012-10-30 01:04:21.336133128 +0100 +++ 
android_kernel_htc_primoc.new/arch/arm/mach-msm/clock-7x30.c	2012-10-30 00:59:44.054004474 +0100 @@ -2853,8 +2853,12 @@
 	OWN(ROW2, 1, "iface_clk", spi_p_clk, "spi_qsd.0"),
 	OWN(ROW2, 9, "core_clk", uart1_clk, "msm_serial.0"),
 	OWN(ROW2, 6, "core_clk", uart1dm_clk, "msm_serial_hs.0"), +#ifdef CONFIG_SERIAL_MSM_HS
 	OWN(ROW2, 6, "core_clk", uart1dm_clk, "msm_serial_hs_brcm.0"),/* for brcm BT */ - OWN(ROW2, 6, "core_clk", uart1dm_clk, "msm_serial_hs_ti_dc.0"),/* for 
ti BT */ +#endif +#ifdef CONFIG_SERIAL_MSM_HS_LPM + OWN(ROW2, 6, "core_clk", uart1dm_clk, "msm_serial_hs_brcm_lpm.0"),/* for brcm BT */ +#endif
 	OWN(ROW2, 8, "core_clk", uart2dm_clk, "msm_serial_hs.1"),
 	OWN(ROW2, 11, "alt_core_clk",	usb_hs_clk,	"msm_otg"),
 	OWN(ROW2, 11, "core_clk",	usb_hs_core_clk, "msm_otg"), @@ -2888,9 +2892,14 @@
 	OWN(GLBL, 13, "iface_clk",	rotator_p_clk,	"footswitch-pcom.6"),
 	{ CLK_LOOKUP("iface_clk", uart1dm_p_clk.c, "msm_serial_hs.0"),
 		O(GLBL), BIT(8), &dummy_clk }, +#ifdef CONFIG_SERIAL_MSM_HS
 	{ CLK_LOOKUP("iface_clk", uart1dm_p_clk.c, "msm_serial_hs_brcm.0"),/* for brcm BT */
 		O(GLBL), BIT(8), &dummy_clk }, - +#endif +#ifdef CONFIG_SERIAL_MSM_HS_LPM + { CLK_LOOKUP("iface_clk", uart1dm_p_clk.c, 
"msm_serial_hs_brcm_lpm.0"),/* for brcm BT */ + O(GLBL), BIT(8), &dummy_clk }, +#endif
 	{ CLK_LOOKUP("iface_clk", uart2dm_p_clk.c, "msm_serial_hs.1"),
 		O(GLBL), BIT(8), &dummy_clk },
 };
diff -u -r -N android_kernel_htc_primoc/arch/arm/mach-msm/include/mach/bcm_bt_lpm.h android_kernel_htc_primoc.new/arch/arm/mach-msm/include/mach/bcm_bt_lpm.h 
--- android_kernel_htc_primoc/arch/arm/mach-msm/include/mach/bcm_bt_lpm.h 1970-01-01 01:00:00.000000000 +0100 +++ 
android_kernel_htc_primoc.new/arch/arm/mach-msm/include/mach/bcm_bt_lpm.h 2012-10-30 01:02:33.973083818 +0100 @@ -0,0 +1,36 @@ +/* + * Copyright (C) 2009 
Google, Inc. + * + * This software is licensed under the terms of the GNU General Public + * License version 2, as published by the Free Software Foundation, 
and + * may be copied, distributed, and modified under those terms. + * + * This program is distributed in the hope that it will be useful, + * but WITHOUT ANY 
WARRANTY; without even the implied warranty of + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the + * GNU General Public License for more 
details. + */ + +#ifndef __ASM_ARCH_BCM_BT_LPM_H +#define __ASM_ARCH_BCM_BT_LPM_H + +#include <linux/serial_core.h> + +/* Uart driver must call this every time 
it beings TX, to ensure + * this driver keeps WAKE asserted during TX. Called with uart + * spinlock held. */ +extern void bcm_bt_lpm_exit_lpm_locked(struct 
uart_port *uport); + +struct bcm_bt_lpm_platform_data { + unsigned int gpio_wake; /* CPU -> BCM wakeup gpio */ + unsigned int gpio_host_wake; /* BCM -> CPU 
wakeup gpio */ + + /* Callback to request the uart driver to clock off. + * Called with uart spinlock held. */ + void (*request_clock_off_locked)(struct 
uart_port *uport); + /* Callback to request the uart driver to clock on. + * Called with uart spinlock held. */ + void (*request_clock_on_locked)(struct 
uart_port *uport); +}; + +#endif diff -u -r -N android_kernel_htc_primoc/arch/arm/mach-msm/include/mach/msm_serial_hs.h 
android_kernel_htc_primoc.new/arch/arm/mach-msm/include/mach/msm_serial_hs.h --- android_kernel_htc_primoc/arch/arm/mach-msm/include/mach/msm_serial_hs.h 
2012-10-30 01:04:21.344133132 +0100 +++ android_kernel_htc_primoc.new/arch/arm/mach-msm/include/mach/msm_serial_hs.h 2012-10-30 01:00:42.260031841 +0100 @@ 
-33,6 +33,11 @@
 	unsigned char bt_wakeup_pin_supported;
 	unsigned char bt_wakeup_pin;	/* Device to Chip */
 	unsigned char host_wakeup_pin; /* Chip to Device */ + +#ifdef CONFIG_SERIAL_BCM_BT_LPM + void (*exit_lpm_cb)(struct uart_port *); +#endif +
 };
 #if 1 //Add by evan.xu@2012-02-02
 /* API for TI_ST */ @@ -46,6 +51,12 @@
 unsigned int msm_hs_tx_empty(struct uart_port *uport);
 void msm_hs_request_clock_off(struct uart_port *uport);
 void msm_hs_request_clock_on(struct uart_port *uport); + +#ifdef CONFIG_SERIAL_BCM_BT_LPM +void msm_hs_request_clock_off_locked(struct uart_port *uport); +void 
msm_hs_request_clock_on_locked(struct uart_port *uport); +#endif +
 void msm_hs_set_mctrl(struct uart_port *uport,
 				    unsigned int mctrl);
 #endif
diff -u -r -N android_kernel_htc_primoc/drivers/tty/serial/bcm_bt_lpm.c android_kernel_htc_primoc.new/drivers/tty/serial/bcm_bt_lpm.c --- 
android_kernel_htc_primoc/drivers/tty/serial/bcm_bt_lpm.c 1970-01-01 01:00:00.000000000 +0100 +++ android_kernel_htc_primoc.new/drivers/tty/serial/bcm_bt_lpm.c 
2012-10-30 01:01:21.067049976 +0100 @@ -0,0 +1,186 @@ +/* + * Copyright (C) 2009 Google, Inc. + * + * This software is licensed under the terms of the GNU 
General Public + * License version 2, as published by the Free Software Foundation, and + * may be copied, distributed, and modified under those terms. + * + * 
This program is distributed in the hope that it will be useful, + * but WITHOUT ANY WARRANTY; without even the implied warranty of + * MERCHANTABILITY or 
FITNESS FOR A PARTICULAR PURPOSE.  See the + * GNU General Public License for more details. + */ + +#include <linux/module.h> +#include 
<linux/platform_device.h> +#include <linux/hrtimer.h> +#include <linux/irq.h> +#include <linux/serial_core.h> +#include <mach/bcm_bt_lpm.h> +#include 
<asm/gpio.h> + +/* + * Manage WAKE and HOST_WAKE low power mode signals for Broadcom + * Bluetooth chipsets. + * + * This driver needs to be tightly coupled 
with a uart driver that supports + * request_clock_off_locked() and request_clock_on_locked(), to clock off and + * on the uart indepdently of Linux 
suspend/resume. + * + * The uart driver needs to call bcm_bt_lpm_exit_lpm_locked() every time it + * begins TX, to ensure this driver keeps WAKE asserted during 
TX. + * + * The callbacks and hijacking of the uart_port struct are not a clean API, + * but the Linux tty and serial core layers do not have a better 
alternative + * right now: there is no good way to plumb uart clock control through these + * layers. See http://lkml.org/lkml/2008/12/19/213 for more 
background. + */ + +struct bcm_bt_lpm { + unsigned int gpio_wake; + unsigned int gpio_host_wake; + + int wake; + int host_wake; + + struct hrtimer 
enter_lpm_timer; + ktime_t enter_lpm_delay; + + struct uart_port *uport; + + void (*request_clock_off_locked)(struct uart_port *uport); + void 
(*request_clock_on_locked)(struct uart_port *uport); +} bt_lpm; + +static void set_wake_locked(int wake) +{ + if (wake == bt_lpm.wake) + return; + bt_lpm.wake = 
wake; + + printk(KERN_ERR "[BT] %s wake=%d\n", __func__, wake); + + gpio_set_value(bt_lpm.gpio_wake, wake); + if (wake || bt_lpm.host_wake) + 
bt_lpm.request_clock_on_locked(bt_lpm.uport); + else + bt_lpm.request_clock_off_locked(bt_lpm.uport); + +} + +static enum hrtimer_restart enter_lpm(struct 
hrtimer *timer) { + unsigned long flags; + + printk(KERN_ERR "[BT] %s\n", __func__); + + spin_lock_irqsave(&bt_lpm.uport->lock, flags); + set_wake_locked(0); + 
spin_unlock_irqrestore(&bt_lpm.uport->lock, flags); + + return HRTIMER_NORESTART; +} + +void bcm_bt_lpm_exit_lpm_locked(struct uart_port *uport) { + 
printk(KERN_ERR "[BT] %s\n", __func__); + + bt_lpm.uport = uport; + + hrtimer_try_to_cancel(&bt_lpm.enter_lpm_timer); + + set_wake_locked(1); + + 
hrtimer_start(&bt_lpm.enter_lpm_timer, bt_lpm.enter_lpm_delay, + HRTIMER_MODE_REL); +} + +EXPORT_SYMBOL(bcm_bt_lpm_exit_lpm_locked); + +static void 
update_host_wake_locked(int host_wake) +{ + printk(KERN_ERR "[BT] %s\n", __func__); + if (host_wake == bt_lpm.host_wake) + return; + bt_lpm.host_wake = 
host_wake; + + if (bt_lpm.wake || host_wake) + bt_lpm.request_clock_on_locked(bt_lpm.uport); + else + bt_lpm.request_clock_off_locked(bt_lpm.uport); +} + 
+static irqreturn_t host_wake_isr(int irq, void *dev) +{ + int host_wake; + unsigned long flags; + + host_wake = gpio_get_value(bt_lpm.gpio_host_wake); + + 
printk(KERN_INFO "[BT] %s host_wake=%d\n", __func__, host_wake); + irq_set_irq_type(irq, host_wake ? IRQF_TRIGGER_LOW : IRQF_TRIGGER_HIGH); + + if 
(!bt_lpm.uport) { + bt_lpm.host_wake = host_wake; + return IRQ_HANDLED; + } + + spin_lock_irqsave(&bt_lpm.uport->lock, flags); + + 
update_host_wake_locked(host_wake); + + spin_unlock_irqrestore(&bt_lpm.uport->lock, flags); + + return IRQ_HANDLED; +} + +static int bcm_bt_lpm_probe(struct 
platform_device *pdev) +{ + int irq; + int ret; + struct bcm_bt_lpm_platform_data *pdata = pdev->dev.platform_data; + + if (bt_lpm.request_clock_off_locked != 
NULL) { + printk(KERN_ERR "Cannot register two bcm_bt_lpm drivers\n"); + return -EINVAL; + } + + bt_lpm.gpio_wake = pdata->gpio_wake; + bt_lpm.gpio_host_wake = 
pdata->gpio_host_wake; + bt_lpm.request_clock_off_locked = pdata->request_clock_off_locked; + bt_lpm.request_clock_on_locked = pdata->request_clock_on_locked; + 
+ hrtimer_init(&bt_lpm.enter_lpm_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL); + bt_lpm.enter_lpm_delay = ktime_set(1, 0); /* 1 sec */ + 
bt_lpm.enter_lpm_timer.function = enter_lpm; + + gpio_set_value(bt_lpm.gpio_wake, 0); + bt_lpm.host_wake = 0; + + irq = gpio_to_irq(bt_lpm.gpio_host_wake); + 
ret = request_irq(irq, host_wake_isr, IRQF_TRIGGER_HIGH, + "bt host_wake", NULL); + if (ret) + return ret; + ret = irq_set_irq_wake(irq, 1); + if (ret) + return 
ret; + + return 0; +} + +static struct platform_driver bcm_bt_lpm_driver = { + .probe = bcm_bt_lpm_probe, + .driver = { + .name = "bcm_bt_lpm", + .owner = 
THIS_MODULE, + }, +}; + +static int __init bcm_bt_lpm_init(void) +{ + return platform_driver_register(&bcm_bt_lpm_driver); +} + +module_init(bcm_bt_lpm_init); 
+MODULE_DESCRIPTION("Broadcom Bluetooth low power mode driver"); +MODULE_AUTHOR("Nick Pelly <npelly@google.com>"); +MODULE_LICENSE("GPL"); diff -u -r -N 
android_kernel_htc_primoc/drivers/tty/serial/Kconfig android_kernel_htc_primoc.new/drivers/tty/serial/Kconfig --- 
android_kernel_htc_primoc/drivers/tty/serial/Kconfig 2012-10-30 01:04:36.261139935 +0100 +++ android_kernel_htc_primoc.new/drivers/tty/serial/Kconfig 2012-10-30 
01:02:11.380073361 +0100 @@ -1356,6 +1356,19 @@
 	select SERIAL_CORE_CONSOLE
 	default n
 
+config SERIAL_MSM_HS_LPM + tristate "MSM UART High Speed: Serial Driver for LPM" + depends on ARCH_MSM + select SERIAL_CORE + select SERIAL_BCM_BT_LPM + help + 
If you have a machine based on MSM family of SoCs, you + can enable its onboard high speed serial port by enabling + this option. This works only when using 
also SERIAL_BCM_BT_LPM + + Choose M here to compile it as a module. The module will be + called msm_serial_hs. +
 config SERIAL_BCM_BT_LPM
 	tristate "Broadcom Bluetooth Low Power Mode"
 	depends on ARM && ARCH_MSM diff -u -r -N android_kernel_htc_primoc/drivers/tty/serial/Makefile android_kernel_htc_primoc.new/drivers/tty/serial/Makefile 
--- android_kernel_htc_primoc/drivers/tty/serial/Makefile	2012-10-30 01:04:36.261139935 +0100 +++ 
android_kernel_htc_primoc.new/drivers/tty/serial/Makefile	2012-10-30 01:01:46.641061881 +0100 @@ -75,9 +75,11 @@
 obj-$(CONFIG_SERIAL_ATMEL) += atmel_serial.o
 obj-$(CONFIG_SERIAL_UARTLITE) += uartlite.o
 obj-$(CONFIG_SERIAL_MSM) += msm_serial.o -obj-$(CONFIG_SERIAL_MSM_HS) += msm_serial_hs.o +#obj-$(CONFIG_SERIAL_MSM_HS) += msm_serial_hs.o
 obj-$(CONFIG_SERIAL_MSM_HS) += msm_serial_hs_brcm.o -obj-$(CONFIG_SERIAL_MSM_HS) += msm_serial_hs_ti_dc.o +obj-$(CONFIG_SERIAL_MSM_HS_LPM) += 
msm_serial_hs_brcm_lpm.o +obj-$(CONFIG_SERIAL_BCM_BT_LPM) += bcm_bt_lpm.o +#obj-$(CONFIG_SERIAL_MSM_HS) += msm_serial_hs_ti_dc.o
 obj-$(CONFIG_SERIAL_MSM_HS_IMC) += msm_serial_hs_imc.o
 obj-$(CONFIG_SERIAL_MSM_HSL) += msm_serial_hs_lite.o
 obj-$(CONFIG_MSM_SERIAL_DEBUGGER) += msm_serial_debugger.o diff -u -r 
-N android_kernel_htc_primoc/drivers/tty/serial/msm_serial_hs_brcm_lpm.c 
android_kernel_htc_primoc.new/drivers/tty/serial/msm_serial_hs_brcm_lpm.c 
--- 
android_kernel_htc_primoc/drivers/tty/serial/msm_serial_hs_brcm_lpm.c 
1970-01-01 01:00:00.000000000 +0100 +++ 
android_kernel_htc_primoc.new/drivers/tty/serial/msm_serial_hs_brcm_lpm.c 
2012-10-30 01:01:31.575054872 +0100 @@ -0,0 +1,2570 @@ +/* 
drivers/serial/msm_serial_hs.c + * + * MSM 7k High speed uart driver + * 
+ * Copyright (c) 2008 Google Inc. + * Copyright (c) 2007-2011, Code 
Aurora Forum. All rights reserved. + * Modified: Nick Pelly 
<npelly@google.com> + * + * All source code in this file is licensed 
under the following license + * except where indicated. + * + * This 
program is free software; you can redistribute it and/or + * modify it 
under the terms of the GNU General Public License + * version 2 as 
published by the Free Software Foundation. + * + * This program is 
distributed in the hope that it will be useful, + * but WITHOUT ANY 
WARRANTY; without even the implied warranty of + * MERCHANTABILITY or 
FITNESS FOR A PARTICULAR PURPOSE. + * See the GNU General Public License 
for more details. + * + * Has optional support for uart power management 
independent of linux + * suspend/resume: + * + * RX wakeup. + * UART 
wakeup can be triggered by RX activity (using a wakeup GPIO on the + * 
UART RX pin). This should only be used if there is not a wakeup + * GPIO 
on the UART CTS, and the first RX byte is known (for example, with the + 
* Bluetooth Texas Instruments HCILL protocol), since the first RX byte 
will + * always be lost. RTS will be asserted even while the UART is off 
in this mode + * of operation. See 
msm_serial_hs_platform_data.rx_wakeup_irq. + */ + +#include 
<linux/module.h> + +#include <linux/serial.h> +#include 
<linux/serial_core.h> +#include <linux/slab.h> +#include <linux/init.h> 
+#include <linux/interrupt.h> +#include <linux/irq.h> +#include 
<linux/io.h> +#include <linux/ioport.h> +#include <linux/kernel.h> 
+#include <linux/timer.h> +#include <linux/clk.h> +#include 
<linux/platform_device.h> +#include <linux/pm_runtime.h> +#include 
<linux/dma-mapping.h> +#include <linux/dmapool.h> +#include 
<linux/wait.h> +#include <linux/sysfs.h> +#include <linux/stat.h> 
+#include <linux/device.h> +#include <linux/wakelock.h> +#include 
<linux/workqueue.h> + +#include <linux/atomic.h> +#include <linux/irq.h> 
+#include <asm/system.h> + +#include <mach/hardware.h> +#include 
<mach/dma.h> +#include <mach/msm_serial_hs.h> +/* for brcm */ +#include 
<linux/gpio.h> +#include <linux/uaccess.h> + +#include 
"msm_serial_hs_hwreg.h" + +#include <linux/poison.h> +#include 
<linux/delay.h> + +static int hs_serial_debug_mask = 1; 
+module_param_named(debug_mask, hs_serial_debug_mask, + int, S_IRUGO | 
S_IWUSR | S_IWGRP); + +/* tx_empty() no spin lock */ +#if 
defined(CONFIG_MACH_RUNNYMEDE) +#define TX_EMPTY_NO_SPINLOCK 1 +#endif + 
+/* for brcm */ +#define USE_BCM_BT_CHIP +#define T_LOW 0 +#define 
T_HIGH 1 +/* for brcm bt serial debug */ +#define BT_SERIAL_DBG + + 
+enum flush_reason { + FLUSH_NONE, + FLUSH_DATA_READY, + 
FLUSH_DATA_INVALID, /* values after this indicate invalid data */ + 
FLUSH_IGNORE = FLUSH_DATA_INVALID, + FLUSH_STOP, + FLUSH_SHUTDOWN, +}; + 
+enum msm_hs_clk_states_e { + MSM_HS_CLK_PORT_OFF, /* port not in use */ 
+ MSM_HS_CLK_OFF, /* clock disabled */ + MSM_HS_CLK_REQUEST_OFF, /* 
disable after TX and RX flushed */ + MSM_HS_CLK_ON, /* clock enabled */ 
+}; + +/* Track the forced RXSTALE flush during clock off sequence. + * 
These states are only valid during MSM_HS_CLK_REQUEST_OFF */ +enum 
msm_hs_clk_req_off_state_e { + CLK_REQ_OFF_START, + 
CLK_REQ_OFF_RXSTALE_ISSUED, + CLK_REQ_OFF_FLUSH_ISSUED, + 
CLK_REQ_OFF_RXSTALE_FLUSHED, +}; + +struct msm_hs_tx { + unsigned int 
tx_ready_int_en; /* ok to dma more tx */ + unsigned int dma_in_flight; 
/* tx dma in progress */ + struct msm_dmov_cmd xfer; + dmov_box 
*command_ptr; + u32 *command_ptr_ptr; + dma_addr_t mapped_cmd_ptr; + 
dma_addr_t mapped_cmd_ptr_ptr; + int tx_count; + dma_addr_t dma_base; + 
struct tasklet_struct tlet; + #ifdef USE_BCM_BT_CHIP /* brcm tx wakelock 
*/ + struct wake_lock brcm_tx_wake_lock; + #endif +}; + +struct 
msm_hs_rx { + enum flush_reason flush; + struct msm_dmov_cmd xfer; + 
dma_addr_t cmdptr_dmaaddr; + dmov_box *command_ptr; + u32 
*command_ptr_ptr; + dma_addr_t mapped_cmd_ptr; + wait_queue_head_t wait; 
+ dma_addr_t rbuffer; + unsigned char *buffer; + unsigned int 
buffer_pending; + struct dma_pool *pool; + struct wake_lock wake_lock; + 
struct delayed_work flip_insert_work; + struct tasklet_struct tlet; + 
struct work_struct tty_work; + struct wake_lock brcm_rx_wake_lock; + 
unsigned int is_brcm_rx_wake_locked; +}; + +enum buffer_states { + 
NONE_PENDING = 0x0, + FIFO_OVERRUN = 0x1, + PARITY_ERROR = 0x2, + 
CHARS_NORMAL = 0x4, +}; + +/* optional low power wakeup, typically on a 
GPIO RX irq */ +struct msm_hs_wakeup { + int irq; /* < 0 indicates low 
power wakeup disabled */ + unsigned char ignore; /* bool */ + + /* bool: 
inject char into rx tty on wakeup */ + unsigned char inject_rx; + char 
rx_to_inject; +}; + +struct msm_hs_port { + struct uart_port uport; + 
unsigned long imr_reg; /* shadow value of UARTDM_IMR */ + struct clk 
*clk; + struct clk *pclk; + struct msm_hs_tx tx; + struct msm_hs_rx rx; 
+ /* gsbi uarts have to do additional writes to gsbi memory */ + /* 
block and top control status block. The following pointers */ + /* keep 
a handle to these blocks. */ + unsigned char __iomem *mapped_gsbi; + int 
dma_tx_channel; + int dma_rx_channel; + int dma_tx_crci; + int 
dma_rx_crci; + struct hrtimer clk_off_timer; /* to poll TXEMT before 
clock off */ + ktime_t clk_off_delay; + enum msm_hs_clk_states_e 
clk_state; + enum msm_hs_clk_req_off_state_e clk_req_off_state; + + 
struct msm_hs_wakeup wakeup; + /* optional callback to exit low power 
mode */ + void (*exit_lpm_cb)(struct uart_port *); + + struct wake_lock 
dma_wake_lock; /* held while any DMA active */ + + #ifdef 
USE_BCM_BT_CHIP /* bt for brcm */ + unsigned char 
bt_wakeup_pin_supported; + unsigned char bt_wakeup_pin; + unsigned char 
bt_wakeup_level; + unsigned char bt_wakeup_assert_inadvance; + unsigned 
char host_wakeup_pin; + unsigned char host_wakeup_level; + unsigned char 
host_want_sleep; + int request_clk_off_delay; + #endif +}; + +#define 
MSM_UARTDM_BURST_SIZE 16 /* DM burst size (in bytes) */ +#define 
UARTDM_TX_BUF_SIZE UART_XMIT_SIZE +#define UARTDM_RX_BUF_SIZE 512 
+#define RETRY_TIMEOUT 5 +#define UARTDM_NR 2 + +static struct 
msm_hs_port q_uart_port[UARTDM_NR]; +static struct platform_driver 
msm_serial_hs_platform_driver; +static struct uart_driver msm_hs_driver; 
+static struct uart_ops msm_hs_ops; +static struct workqueue_struct 
*msm_hs_workqueue; + +#define UARTDM_TO_MSM(uart_port) \ + 
container_of((uart_port), struct msm_hs_port, uport) + +static ssize_t 
show_clock(struct device *dev, struct device_attribute *attr, + char 
*buf) +{ +#if 0 + int state = 1; + enum msm_hs_clk_states_e clk_state; + 
unsigned long flags; + + struct platform_device *pdev = 
container_of(dev, struct + platform_device, dev); + struct msm_hs_port 
*msm_uport = &q_uart_port[pdev->id]; + + 
spin_lock_irqsave(&msm_uport->uport.lock, flags); + clk_state = 
msm_uport->clk_state; + spin_unlock_irqrestore(&msm_uport->uport.lock, 
flags); + + if (clk_state <= MSM_HS_CLK_OFF) + state = 0; + + return 
snprintf(buf, PAGE_SIZE, "%d\n", state); +#else + return 0; +#endif +} + 
+static ssize_t set_clock(struct device *dev, struct device_attribute 
*attr, + const char *buf, size_t count) +{ +#if 0 + int state; + struct 
platform_device *pdev = container_of(dev, struct + platform_device, 
dev); + struct msm_hs_port *msm_uport = &q_uart_port[pdev->id]; + + 
state = buf[0] - '0'; + switch (state) { + case 0: { + 
msm_hs_request_clock_off(&msm_uport->uport); + break; + } + case 1: { + 
msm_hs_request_clock_on(&msm_uport->uport); + break; + } + default: { + 
return -EINVAL; + } + } + return count; +#else + return 0; +#endif +} + 
+static DEVICE_ATTR(clock, S_IWUSR | S_IRUGO, show_clock, set_clock); + 
+static inline unsigned int use_low_power_wakeup(struct msm_hs_port 
*msm_uport) +{ + return (msm_uport->wakeup.irq > 0); +} + +static inline 
int is_gsbi_uart(struct msm_hs_port *msm_uport) +{ + /* assume gsbi uart 
if gsbi resource found in pdata */ + return ((msm_uport->mapped_gsbi != 
NULL)); +} + +static inline unsigned int msm_hs_read(struct uart_port 
*uport, + unsigned int offset) +{ + return readl_relaxed(uport->membase 
+ offset); +} + +static inline void msm_hs_write(struct uart_port 
*uport, unsigned int offset, + unsigned int value) +{ + 
writel_relaxed(value, uport->membase + offset); +} + +static void 
msm_hs_release_port(struct uart_port *port) +{ + struct msm_hs_port 
*msm_uport = UARTDM_TO_MSM(port); + struct platform_device *pdev = 
to_platform_device(port->dev); + struct resource *gsbi_resource; + 
resource_size_t size; + + if (is_gsbi_uart(msm_uport)) { + 
iowrite32(GSBI_PROTOCOL_IDLE, msm_uport->mapped_gsbi + + 
GSBI_CONTROL_ADDR); + gsbi_resource = platform_get_resource_byname(pdev, 
+ IORESOURCE_MEM, + "gsbi_resource"); + if (gsbi_resource == NULL) { + 
printk(KERN_ERR "Can't get GSBI RES\n"); + return; + } + size = 
gsbi_resource->end - gsbi_resource->start + 1; + 
release_mem_region(gsbi_resource->start, size); + 
iounmap(msm_uport->mapped_gsbi); + msm_uport->mapped_gsbi = NULL; +	
}
+} + +static int msm_hs_request_port(struct uart_port *port) +{ + struct msm_hs_port *msm_uport = UARTDM_TO_MSM(port); + struct platform_device *pdev = 
to_platform_device(port->dev); + struct resource *gsbi_resource; + resource_size_t size; + + gsbi_resource = platform_get_resource_byname(pdev, + 
IORESOURCE_MEM, + "gsbi_resource"); + + if (gsbi_resource) { + size = gsbi_resource->end - gsbi_resource->start + 1; + if 
(unlikely(!request_mem_region(gsbi_resource->start, size, + "msm_serial_hs"))) + return -EBUSY; + msm_uport->mapped_gsbi = ioremap(gsbi_resource->start, + 
size); + if (!msm_uport->mapped_gsbi) { + release_mem_region(gsbi_resource->start, size); + return -EBUSY; + } + } + /* no gsbi uart */ + return 0; +} + +static 
int __devexit msm_hs_remove(struct platform_device *pdev) +{ + + struct msm_hs_port *msm_uport; + struct device *dev; + + if (pdev->id < 0 || pdev->id >= 
UARTDM_NR) { + printk(KERN_ERR "[BT]Invalid plaform device ID = %d\n", + pdev->id); + return -EINVAL; + } + + msm_uport = &q_uart_port[pdev->id]; + dev = 
msm_uport->uport.dev; + + sysfs_remove_file(&pdev->dev.kobj, &dev_attr_clock.attr); + + dma_unmap_single(dev, msm_uport->rx.mapped_cmd_ptr, sizeof(dmov_box), + 
DMA_TO_DEVICE); + dma_pool_free(msm_uport->rx.pool, msm_uport->rx.buffer, + msm_uport->rx.rbuffer); + dma_pool_destroy(msm_uport->rx.pool); + + 
dma_unmap_single(dev, msm_uport->rx.cmdptr_dmaaddr, sizeof(u32 *), + DMA_TO_DEVICE); + dma_unmap_single(dev, msm_uport->tx.mapped_cmd_ptr_ptr, sizeof(u32 *), + 
DMA_TO_DEVICE); + dma_unmap_single(dev, msm_uport->tx.mapped_cmd_ptr, sizeof(dmov_box), + DMA_TO_DEVICE); + + /* destroy tx wakelock */ + 
wake_lock_destroy(&msm_uport->tx.brcm_tx_wake_lock); + /* destroy rx wakelock */ + wake_lock_destroy(&msm_uport->rx.brcm_rx_wake_lock); + + 
wake_lock_destroy(&msm_uport->rx.wake_lock); + wake_lock_destroy(&msm_uport->dma_wake_lock); + + uart_remove_one_port(&msm_hs_driver, &msm_uport->uport); + 
clk_put(msm_uport->clk); + + /* Free the tx resources */ + kfree(msm_uport->tx.command_ptr); + kfree(msm_uport->tx.command_ptr_ptr); + + /* Free the rx 
resources */ + kfree(msm_uport->rx.command_ptr); + kfree(msm_uport->rx.command_ptr_ptr); + + iounmap(msm_uport->uport.membase); + + return 0; +} + +static int 
msm_hs_init_clk(struct uart_port *uport) +{ + int ret; + struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport); + + wake_lock(&msm_uport->dma_wake_lock); + /* 
Set up the MREG/NREG/DREG/MNDREG */ + ret = clk_set_rate(msm_uport->clk, uport->uartclk); + if (ret) { + printk(KERN_WARNING "[BT]Error setting clock rate on 
UART\n"); + return ret; + } + + ret = clk_enable(msm_uport->clk); + if (ret) { + printk(KERN_ERR "[BT]Error could not turn on UART clk\n"); + return ret; +	
}
+ if (msm_uport->pclk) { + ret = clk_enable(msm_uport->pclk); + if (ret) { + dev_err(uport->dev, + "[BT]Error could not turn on UART pclk\n"); + return ret; + } 
+ } + + msm_uport->clk_state = MSM_HS_CLK_ON; + + return 0; +} + +/* + * programs the UARTDM_CSR register with correct bit rates + * + * Interrupts should be 
disabled before we are called, as + * we modify Set Baud rate + * Set receive stale interrupt level, dependant on Bit Rate + * Goal is to have around 8 ms 
before indicate stale. + * roundup (((Bit Rate * .008) / 10) + 1 + */ +static void msm_hs_set_bps_locked(struct uart_port *uport, + unsigned int bps) +{ + 
unsigned long rxstale; + unsigned long data; + struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport); + + switch (bps) { + case 300: + msm_hs_write(uport, 
UARTDM_CSR_ADDR, 0x00); + rxstale = 1; + break; + case 600: + msm_hs_write(uport, UARTDM_CSR_ADDR, 0x11); + rxstale = 1; + break; + case 1200: + 
msm_hs_write(uport, UARTDM_CSR_ADDR, 0x22); + rxstale = 1; + break; + case 2400: + msm_hs_write(uport, UARTDM_CSR_ADDR, 0x33); + rxstale = 1; + break; + case 
4800: + msm_hs_write(uport, UARTDM_CSR_ADDR, 0x44); + rxstale = 1; + break; + case 9600: + msm_hs_write(uport, UARTDM_CSR_ADDR, 0x55); + rxstale = 2; + break; + 
case 14400: + msm_hs_write(uport, UARTDM_CSR_ADDR, 0x66); + rxstale = 3; + break; + case 19200: + msm_hs_write(uport, UARTDM_CSR_ADDR, 0x77); + rxstale = 4; + 
break; + case 28800: + msm_hs_write(uport, UARTDM_CSR_ADDR, 0x88); + rxstale = 6; + break; + case 38400: + msm_hs_write(uport, UARTDM_CSR_ADDR, 0x99); + rxstale 
= 8; + break; + case 57600: + msm_hs_write(uport, UARTDM_CSR_ADDR, 0xaa); + rxstale = 16; + break; + case 76800: + msm_hs_write(uport, UARTDM_CSR_ADDR, 0xbb); + 
rxstale = 16; + break; + case 115200: + msm_hs_write(uport, UARTDM_CSR_ADDR, 0xcc); + rxstale = 31; + break; + case 230400: + msm_hs_write(uport, 
UARTDM_CSR_ADDR, 0xee); + rxstale = 31; + break; + case 460800: + msm_hs_write(uport, UARTDM_CSR_ADDR, 0xff); + rxstale = 31; + break; + case 4000000: + case 
3686400: + case 3200000: + case 3500000: + case 3000000: + case 2500000: + case 1500000: + case 1152000: + case 1000000: + case 921600: + msm_hs_write(uport, 
UARTDM_CSR_ADDR, 0xff); + rxstale = 31; + break; + default: + msm_hs_write(uport, UARTDM_CSR_ADDR, 0xff); + /* default to 9600 */ + bps = 9600; + rxstale = 2; + 
break; + } + /* + * uart baud rate depends on CSR and MND Values + * we are updating CSR before and then calling + * clk_set_rate which updates MND Values. 
Hence + * dsb requires here. + */ + mb(); + if (bps > 460800) + uport->uartclk = bps * 16; + else + uport->uartclk = 7372800; + + if 
(clk_set_rate(msm_uport->clk, uport->uartclk)) { + printk(KERN_WARNING "[BT]Error setting clock rate on UART\n"); + return; + } + + data = rxstale & 
UARTDM_IPR_STALE_LSB_BMSK; + data |= UARTDM_IPR_STALE_TIMEOUT_MSB_BMSK & (rxstale << 2); + + msm_hs_write(uport, UARTDM_IPR_ADDR, data); + /* + * It is 
suggested to do reset of transmitter and receiver after + * changing any protocol configuration. Here Baud rate and stale + * timeout are getting updated. Hence 
reset transmitter and receiver. + */ + msm_hs_write(uport, UARTDM_CR_ADDR, RESET_TX); + msm_hs_write(uport, UARTDM_CR_ADDR, RESET_RX); +} + + +static void 
msm_hs_set_std_bps_locked(struct uart_port *uport, + unsigned int bps) +{ + unsigned long rxstale; + unsigned long data; + + switch (bps) { + case 9600: + 
msm_hs_write(uport, UARTDM_CSR_ADDR, 0x99); + rxstale = 2; + break; + case 14400: + msm_hs_write(uport, UARTDM_CSR_ADDR, 0xaa); + rxstale = 3; + break; + case 
19200: + msm_hs_write(uport, UARTDM_CSR_ADDR, 0xbb); + rxstale = 4; + break; + case 28800: + msm_hs_write(uport, UARTDM_CSR_ADDR, 0xcc); + rxstale = 6; + break; 
+ case 38400: + msm_hs_write(uport, UARTDM_CSR_ADDR, 0xdd); + rxstale = 8; + break; + case 57600: + msm_hs_write(uport, UARTDM_CSR_ADDR, 0xee); + rxstale = 16; 
+ break; + case 115200: + msm_hs_write(uport, UARTDM_CSR_ADDR, 0xff); + rxstale = 31; + break; + default: + msm_hs_write(uport, UARTDM_CSR_ADDR, 0x99); + /* 
default to 9600 */ + bps = 9600; + rxstale = 2; + break; + } + + data = rxstale & UARTDM_IPR_STALE_LSB_BMSK; + data |= UARTDM_IPR_STALE_TIMEOUT_MSB_BMSK & 
(rxstale << 2); + + msm_hs_write(uport, UARTDM_IPR_ADDR, data); +} + +/* + * termios : new ktermios + * oldtermios: old ktermios previous setting + * + * 
Configure the serial port + */ +static void msm_hs_set_termios(struct uart_port *uport, + struct ktermios *termios, + struct ktermios *oldtermios) +{ + unsigned 
int bps; + unsigned long data; + unsigned long flags; + unsigned int c_cflag = termios->c_cflag; + struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport); + + 
spin_lock_irqsave(&uport->lock, flags); + clk_enable(msm_uport->clk); + + /* + * Disable Rx channel of UARTDM + * DMA Rx Stall happens if enqueue and flush of 
Rx command happens + * concurrently. Hence before changing the baud rate/protocol + * configuration and sending flush command to ADM, disable the Rx + * channel 
of UARTDM. + * Note: should not reset the receiver here immediately as it is not + * suggested to do disable/reset or reset/disable at the same time. + */ + 
data = msm_hs_read(uport, UARTDM_DMEN_ADDR); + data &= ~UARTDM_RX_DM_EN_BMSK; + msm_hs_write(uport, UARTDM_DMEN_ADDR, data); + + /* 300 is the minimum baud 
support by the driver */ + bps = uart_get_baud_rate(uport, termios, oldtermios, 200, 4000000); + + /* Temporary remapping 200 BAUD to 3.2 mbps */ + if (bps == 
200) + bps = 3200000; + + uport->uartclk = clk_get_rate(msm_uport->clk); + if (!uport->uartclk) + msm_hs_set_std_bps_locked(uport, bps); + else + 
msm_hs_set_bps_locked(uport, bps); + + data = msm_hs_read(uport, UARTDM_MR2_ADDR); + data &= ~UARTDM_MR2_PARITY_MODE_BMSK; + /* set parity */ + if (PARENB == 
(c_cflag & PARENB)) { + if (PARODD == (c_cflag & PARODD)) + data |= ODD_PARITY; + else if (CMSPAR == (c_cflag & CMSPAR)) + data |= SPACE_PARITY; + else + data 
|= EVEN_PARITY;
+ } + + /* Set bits per char */ + data &= ~UARTDM_MR2_BITS_PER_CHAR_BMSK; + + switch (c_cflag & CSIZE) { + case CS5: + data |= FIVE_BPC; + break; + case CS6: + 
data |= SIX_BPC; + break; + case CS7: + data |= SEVEN_BPC; + break; + default: + data |= EIGHT_BPC; + break; + } + /* stop bits */ + if (c_cflag & CSTOPB) { + 
data |= STOP_BIT_TWO; + } else { + /* otherwise 1 stop bit */ + data |= STOP_BIT_ONE; + } + data |= UARTDM_MR2_ERROR_MODE_BMSK; + /* write parity/bits per 
char/stop bit configuration */ + msm_hs_write(uport, UARTDM_MR2_ADDR, data); + + /* Configure HW flow control */ + data = msm_hs_read(uport, UARTDM_MR1_ADDR); + 
+ data &= ~(UARTDM_MR1_CTS_CTL_BMSK | UARTDM_MR1_RX_RDY_CTL_BMSK); + + if (c_cflag & CRTSCTS) { + data |= UARTDM_MR1_CTS_CTL_BMSK; + data |= 
UARTDM_MR1_RX_RDY_CTL_BMSK; + } + + msm_hs_write(uport, UARTDM_MR1_ADDR, data); + + uport->ignore_status_mask = termios->c_iflag & INPCK; + 
uport->ignore_status_mask |= termios->c_iflag & IGNPAR; + uport->read_status_mask = (termios->c_cflag & CREAD); + + msm_hs_write(uport, UARTDM_IMR_ADDR, 0); + + 
/* Set Transmit software time out */ + uart_update_timeout(uport, c_cflag, bps); + + msm_hs_write(uport, UARTDM_CR_ADDR, RESET_RX); + msm_hs_write(uport, 
UARTDM_CR_ADDR, RESET_TX); + + if (msm_uport->rx.flush == FLUSH_NONE) { + wake_lock(&msm_uport->rx.wake_lock); + msm_uport->rx.flush = FLUSH_IGNORE; + /* + * 
Before using dmov APIs make sure that + * previous writel are completed. Hence + * dsb requires here. + */ + mb(); + /* do discard flush */ + 
msm_dmov_stop_cmd(msm_uport->dma_rx_channel, + &msm_uport->rx.xfer, 0); + } + + msm_hs_write(uport, UARTDM_IMR_ADDR, msm_uport->imr_reg); + /* calling other 
hardware component here clk_disable API. */ + mb(); + clk_disable(msm_uport->clk); + spin_unlock_irqrestore(&uport->lock, flags); +} + +/* + * Standard API, 
Transmitter + * Any character in the transmit shift register is sent + */ +unsigned int brcm_msm_hs_tx_empty(struct uart_port *uport) +{ + unsigned int data; + 
unsigned int ret = 0; + struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport); + +#ifndef TX_EMPTY_NO_SPINLOCK + unsigned long flags; + 
spin_lock_irqsave(&uport->lock, flags); +#endif + clk_enable(msm_uport->clk); + + data = msm_hs_read(uport, UARTDM_SR_ADDR); + if (data & UARTDM_SR_TXEMT_BMSK) 
+ ret = TIOCSER_TEMT; + + clk_disable(msm_uport->clk); +#ifndef TX_EMPTY_NO_SPINLOCK + spin_unlock_irqrestore(&uport->lock, flags); +#endif + return ret; +} + 
+/* + * Standard API, Stop transmitter. + * Any character in the transmit shift register is sent as + * well as the current data mover transfer . + */ +static 
void msm_hs_stop_tx_locked(struct uart_port *uport) +{ + struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport); + + msm_uport->tx.tx_ready_int_en = 0; +} + +/* + 
* Standard API, Stop receiver as soon as possible. + * + * Function immediately terminates the operation of the + * channel receiver and any incoming characters 
are lost. None + * of the receiver status bits are affected by this command and + * characters that are already in the receive FIFO there. + */ +static void 
msm_hs_stop_rx_locked(struct uart_port *uport) +{ + struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport); + unsigned int data; + + clk_enable(msm_uport->clk); + 
+ /* disable dlink */ + data = msm_hs_read(uport, UARTDM_DMEN_ADDR); + data &= ~UARTDM_RX_DM_EN_BMSK; + msm_hs_write(uport, UARTDM_DMEN_ADDR, data); + + /* 
calling DMOV or CLOCK API. Hence mb() */ + mb(); + /* Disable the receiver */ + if (msm_uport->rx.flush == FLUSH_NONE) { + wake_lock(&msm_uport->rx.wake_lock); 
+ /* do discard flush */ + msm_dmov_stop_cmd(msm_uport->dma_rx_channel, + &msm_uport->rx.xfer, 0); + } + if (msm_uport->rx.flush != FLUSH_SHUTDOWN) + 
msm_uport->rx.flush = FLUSH_STOP; + + clk_disable(msm_uport->clk); +} + +/* Transmit the next chunk of data */ +static void msm_hs_submit_tx_locked(struct 
uart_port *uport) +{ + int left; + int tx_count; + int aligned_tx_count; + dma_addr_t src_addr; + dma_addr_t aligned_src_addr; + struct msm_hs_port *msm_uport = 
UARTDM_TO_MSM(uport); + struct msm_hs_tx *tx = &msm_uport->tx; + struct circ_buf *tx_buf = &msm_uport->uport.state->xmit; + + if (uart_circ_empty(tx_buf) || 
uport->state->port.tty->stopped) { + msm_hs_stop_tx_locked(uport); + return; + } + + tx->dma_in_flight = 1; + + tx_count = uart_circ_chars_pending(tx_buf); + + 
if (UARTDM_TX_BUF_SIZE < tx_count) + tx_count = UARTDM_TX_BUF_SIZE; + + left = UART_XMIT_SIZE - tx_buf->tail; + + if (tx_count > left) + tx_count = left; + + 
src_addr = tx->dma_base + tx_buf->tail; + /* Mask the src_addr to align on a cache + * and add those bytes to tx_count */ + aligned_src_addr = src_addr & 
~(dma_get_cache_alignment() - 1); + aligned_tx_count = tx_count + src_addr - aligned_src_addr; + + dma_sync_single_for_device(uport->dev, aligned_src_addr, + 
aligned_tx_count, DMA_TO_DEVICE); + + tx->command_ptr->num_rows = (((tx_count + 15) >> 4) << 16) | + ((tx_count + 15) >> 4); + tx->command_ptr->src_row_addr = 
src_addr; + + dma_sync_single_for_device(uport->dev, tx->mapped_cmd_ptr, + sizeof(dmov_box), DMA_TO_DEVICE); + + *tx->command_ptr_ptr = CMD_PTR_LP | 
DMOV_CMD_ADDR(tx->mapped_cmd_ptr); + + /* Save tx_count to use in Callback */ + tx->tx_count = tx_count; + msm_hs_write(uport, UARTDM_NCF_TX_ADDR, tx_count); + 
+ /* Disable the tx_ready interrupt */ + msm_uport->imr_reg &= ~UARTDM_ISR_TX_READY_BMSK; + msm_hs_write(uport, UARTDM_IMR_ADDR, msm_uport->imr_reg); + /* 
Calling next DMOV API. Hence mb() here. */ + mb(); + + dma_sync_single_for_device(uport->dev, tx->mapped_cmd_ptr_ptr, + sizeof(u32 *), DMA_TO_DEVICE); + + if 
((tx->xfer.list.next == LIST_POISON1) + || (tx->xfer.list.next == NULL)) + msm_dmov_enqueue_cmd(msm_uport->dma_tx_channel, &tx->xfer); + else + printk(KERN_ERR 
"[BT]Error: tx already started in dmov\n"); +} + +/* Start to receive the next chunk of data */ +static void msm_hs_start_rx_locked(struct uart_port *uport) +{ 
+ struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport); + unsigned int buffer_pending = msm_uport->rx.buffer_pending; + unsigned int data; + + 
msm_uport->rx.buffer_pending = 0; + if (buffer_pending && hs_serial_debug_mask) + printk(KERN_ERR "[BT]Error: rx started in buffer state = %x", + 
buffer_pending);
